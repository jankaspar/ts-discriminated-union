<%

const MAX_UNION = 24

function types(n, exclude){
  var numbers = _.range(1, n+1);
  var filtered = _.filter(numbers, n => n != exclude)
  return _.map(filtered, n => 'T' + n);
}

function list(n, excluded){
  return types(n, excluded).join(', ');
}
function union(n, excluded){
  return types(n, excluded).join(' | ');
}

function forRange(start, end, a){
  for (var i = start; i <= end; i++) {
    a(i);
  }
}
// This file is template for union.ts %>  // DO NOT EDIT THIS FILE IT IS GENERATED, EDIT union.ts.tmpl instead

module tsDiscriminatedUnion{

export interface Union<TValue, TMatchable> {
  match(value: TValue): TMatchable // in typescript 1.8 null is considered subtype of any type
  type: TValue  // keep the combined type for convenience
}
<% forRange(1, MAX_UNION, i =>{ %>
export interface Union<%= i %><<%= list(i) %>> extends Union<<%= union(i) %>, FirstMatchable<%= i %><<%= list(i) %>>> {} <% }) %>

export interface FirstMatchable1<T>{
  case<TReturn>(type: TypeDescriptor<T>, action: (v:T) => TReturn): { result(): TReturn}
}
<% forRange(2, MAX_UNION, i =>{ %>
export interface FirstMatchable<%= i %><<%= list(i) %>> { <%
  forRange(1, i, n =>{ %>
  case<TReturn>(type: TypeDescriptor<T<%= n %>>, action: (v:T<%= n %>) => TReturn): Matchable<%= i-1 %><<%= list(i, n) %>, TReturn> <% }) %>
}<% }) %>

export interface Matchable<T, TResult>{
  default<TReturn>(action: (a:T) => TReturn): { result(): TResult | TReturn }
}
export interface Matchable1<T, TResult> extends Matchable<T, TResult>{
  case<TReturn>(type: TypeDescriptor<T>, action: (v:T) => TReturn): { result(): TResult | TReturn}
}
<% forRange(2, MAX_UNION, i =>{ %>
export interface Matchable<%= i %><<%= list(i) %>, TResult> extends Matchable<<%= union(i) %>, TResult>{ <%
  forRange(1, i, n =>{ %>
  case<TReturn>(type: TypeDescriptor<T<%= n %>>, action: (v:T<%= n %>) => TReturn): Matchable<%= i-1 %><<%= list(i, n) %>, TResult | TReturn> <% }) %>
}<% }) %>

<% forRange(1, MAX_UNION, i =>{ %>
export function union<<%= list(i) %>>(<%= types(i).map(t => t.toLowerCase() + ': TypeDescriptor<' + t + '>').join(', ') %>): Union<%= i %><<%= list(i) %>><% }) %>
export function union(): any{
  return {
   match(value: any){
     var result: any;
     var match = false;
     return {
       default<T>(action: (v:T) => any) {
         result = action(value);
         match = true;
         return this;
       },
       case<T>(type: TypeDescriptor<T>, action: (v:T) => any) {
         if(!match && matchType<T>(type, value)) {
           result = action(value);
         }
         return this;
       },
       result: ()=> result
     }
   }
  }
}
}
